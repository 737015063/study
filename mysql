mysql:简单易用、功能、性能、可靠性

通过对应参数开启功能
物理文件组成：
日志文件：错误日志默认关闭可配置路径名称，flush logs可备份
          二进制日志即bin log  --log-bin指定文件开启，可设置文件大小，针对特定的数据库记录，记录文件绝对路径
          查询日志体积大开启影响性能，可追踪sql性能
          慢查询日志记录时间长的sql
          innodb redo日志 undo保证事务安全

数据文件：.frm文件表结构定义消息
          .MYD myisam引擎表数据
          .MYI MYISAM索引相关信息
          
          .ibd和ibdata存放innodb数据
          
replication相关文件：master.info存在slave记录master信息和日志读取到的位置
                    relay log 存放io线程从master读取到的bin log ，sql线程解析sql并应用
                    relay-log.info记录rela log信息
                    
其他文件：system config file系统配置文件 如[mysqld]参数项
         pid file存放进程id
         socket file
         

逻辑模块组成(两层)：
                  sql layer（很多小模块 ）:权限，sql解析，执行优化计划，query cache
                  storage engine layer 数据存取实现部分
                  
sql layer:初始化模块mysql server启动时的初始化操作如buffer和cache结构、系统变量设定、存储引擎设置、内存空间申请
          核心api模块提供些优化底层操作功能的实现如底层数据结构和算法实现，字符串和数字处理，小文件io，格式化输出，内存管理
          网络交互模块抽象出模块交互的接口api，实现数据接收与发送
          client & server交互协议模块自己的信息交互协议建立在 tcp/ip和socket上
          用户模块登录连接权限控制和授权管理=门卫
          访问控制模块监控用户动作根据授权和约束控制数据的访问，结合用户模块组成权限安全管理
          连接管理&连接线程和线程管理：连接管理模块监听接收请求，转发给线程管理模块线程创建和线程的cache，线程处理请求传递结果
          query解析和转发模块解析语义和语法，进行分类并转发
          query cache模块cache query类的请求根据query hash值，数据变化后失效，读写比例高用处大
          query优化器模块根据语句和统计信息和算法分析优化query请求
          表变更管理模块处理ddl（数据定义语言如create）和dml（数据操作语curd）语句
          表维护模块表状态检查错误修复，优化和分析
          系统状态管理模块将状态信息返回给用户
          表管理器维护.frm文件，一个cache它cache各个表结构信息，tabl级别的锁管理
          日志记录模块记录日志binlog,slow query log等
          复制模块读取mastr binlog与slave io线程交互，slave io线程读取binlog西尔relay log，slave sql线程读取relay log解析成sql运行
          存储引擎接口模块抽象化类实现存储引擎的可插拔

过程分析：初始化模块初始化整个系统-->连接管理模块接手监听tcp/ip和socket启动完成准备接受请求-->请求通过网络交互模块，
          用户模块检查授权，连接管理将请求转发线程管理模块请求连接线程建立连接，检查连接池是否由线程或创建接收请求-->转给解析query模块与转发
          （command不解析直接执行），查询cache模块是否缓存，是直接给线程返回结果给客户端-->query优化器模块 ，如果是dml,ddl交给表变更模块，
          统计，检测，修复，整理则交由表维护模块，复制相关由复制模块处理，状态query由系统状态模块处理-->访问控制检查权限，有由表管理模块请求表获取锁，
          表变更模块更加meta信息提交请求给存储引擎模块-->处理完交由连接线程返回成功或失败或错误信息然后继续等待请求或断开连接-->整个过程数据发生改变
          且开启binlog日志模块会记录变更，以上各个模块依赖核心api模块的内存管理和文件io,字符和数字处理
          
mysql工具

存储引擎：MyIsam表锁定、innodb事务安全支持、数据多版本读取、行锁定通过索引、外键支持不建议由性能消耗

网络层：广域网威胁和局域网内部、网络设备出入口
主机层：拦截未授权用户，安全设置不足
数据库层：访问控制授权管理
sql层 ：利用解析原理和校验漏洞提交非法数据
代码层

权限系统：grant tables,gloal、database、table、column、routine level
访问控制实现原理：先用户模块校验host、username、pwd信息，再访问控制模块解析所需权限去匹配用户权限
                 了解主机来源，了解用户需求要做什么，分配对于权限账号，工作分类
                 
数据备份与恢复：数据丢失恢复，新建环境与迁移恢复
逻辑备份：生成insert语句备份，执行脚本恢复，做恢复测试验证备份是否有效
备份策略根据场景和重要性，和要求指定，时间快慢与数据完整性

数据库应用系统（使用数据库的应用）：数据操作通过数据库提供接口完成，性能到底与哪些地方有关，找出应用系统的性能问题根本原因，给出优化方案
功能初衷为用户提供某种服务满足需求，不合理需求功能是否画蛇添足
 
商业需求对性能影响：(系统应该有什么不应该有什么）
   需求合理性分析：第一、每次产品经理们提出新的项目（功能需求）的时候，应该要求他们同时给出该项目的预 期收益的量化指标，以备项目上先后统计评估投入产出比率； 
               第二、在每次项目进行过程中，应该详细记录所有的资源投入，包括人力投入，硬件设施的投入， 以及其他任何项目相关的资源投入； 
               第三、项目（或者功能需求）上线之后应该及时通过手机相关数据统计出项目的实际收益值，以便 计算投入产出比率的时候使用； 
               第四、技术部门应该尽可能推动设计出一个项目（或者功能需求）的投入产出比率的计算规则。
               项目上线一段时间，通过项目实际收益的统计数据和项目的投入资源量，计算出整个项目的实际投入产出值，公布给参与项目的部门，存放以备后查。
               有了实际的投入产出比率，我们就可以和项目立项之初产品经理们的预期投入产出比率做出比较， 判定出这个项目做的是否值得。
               当积累了较多的项目投入产出比率，我们根据历史数据分析一个项目合理的投入产出比率应该是多少。
               在项目立项初，我们就可以判定出产品经理预期投入产出比率是否合理，项目是否真的有进行的必要。
               拿出数据给看，让他知道功能并不是越多越好， 让他知道有些功能是应该撤下来的，即使撤下该功能可能需要投入不少资源
               利益与业绩冲突，成本投入，技术复杂度的负面影响
               
   功能分析：拿简单的功能来分析一下。 需求：一个论坛帖子总量的统计 附加要求：实时更新
          这个功能容易实现，执行一条 SELECT COUNT(*)的 Query 就可以得到结果了
          确实只需要如此简单的一个 Query 就可以得到结果。如果我们采用不是MyISAM存储引擎（会记录总数），而是使用的 Innodb 的存储引擎，
          试想，帖子的表中有上千万的帖子的时候，执行这条 Query 语句需要多少成本？不可能10秒之内完成次查询
          既然这样查询不行，那我们是不是该专门为这个功能建一个表，就只有一个字段，一条记录，就存放这个统计量，每次有新的帖子产生的时候，
          都将这个值增加1，这样我们每次都只需要查询这个表就可 以得到结果了，这个效率肯定能够满足要求了。
          确实，查询效率肯定能够满足要求，可是如果我们的系 统帖子产生很快，在高峰时期可能每秒就有几十甚至上百个帖子新增操作的时候，
          恐怕这个统计表又要 成为大家的噩梦了。要么因为并发的问题造成统计结果的不准确，要么因为锁资源争用严重造成整体性 能的大幅度下降。
          问题的焦点不应该是实现这个功能的技术细节，而是在于这个功能的附加要求“实时更 新”上面。
          当一个论坛的帖子数量很大了之后，到底有多少人会关注这个统计数据是否是实时变化的？ 
          只要去掉了这个“实时更新”的附加条件，我们就可以非常容易的实现这个功能了。就像之前所提 到的那样，通过创建一个统计表，
          然后通过一个定时任务每隔一定时间段去更新一次里面的统计值，这 样既可以解决统计值查询的效率问题，又可以保证不影响新发贴的效率，一举两得。
          在我们应用的系统中还有很多类似的功能点可以优化。分析出那些可以不实时和不完全精确的地方，作出一些相应的折中调整，会给大家带来巨大性能提升。
          如某些场合的列表页面参与列 表的数据量达到一个数量级之后，完全可以不用准确的显示这个列表总共有多少条信息，总共分了多少
          页，而只需要一个大概的估计值或者一个时间段之前的统计值。这样就省略了我们的分页程序需要在分 以前实时 COUNT 出满足条件的记录数。
   功能下线机制：无用功能堆积使系统过度复杂影响整体性能
             很多时候，为系统增加某个功能可能并不需要花费太多的成本，而要想将一个已经运行了一段时间的功能从原有系统中撤下来却是非常困难的。
             对于开发部门，可能要重新整理很多的代码，找出可能存在与增加该功能所编写的代码有交 集的其他功能点，删除没有关联的代码，修改有关联的代码；
             对于测试部门，由于功能的变动，必须要回归测试所有相关的功能点是否正常。可能由于界定困难，不得不将回归范围扩展到很大，测试工作量也很大。
             最后，所有与撤除下线某个功能相关的工作参与者来说，又无法带来任何实质性的收益，而恰恰相 反是，带来的只可能是风险。
             由于上面的这几个因素，可能很少有公司能够有很完善的项目（或者功能）下线机制，也很少有公 司能做到及时将系统中某些不合适的功能下线。
             我们所面对的应用系统总是越来越复杂庞大，短期内的复杂可能并无太大问题，但是随着时间的积累，我们所面对的系统就会变得极其臃肿。
             不仅维护困难，性能也会越来越差。尤其是有些并不合理的功能，在设计之初或者是刚上线的时候 由于数据量较小，带来不了多少性能损耗。
             可随着时间的推移，数据库中的数据量越来越大，数据检索 越来越困难，对真个系统带来的资源消耗也就越来越大。
             系统复杂度给后续功能的开发带来实现的复杂度，本来简单功能，因为系统的复杂而增加很多的逻辑判断，造成系统应用程序的计算量增加，性能会受到影响。
             而如果这些逻辑判断还需要与数据库交互通过持久化的数据来完成的话，所带来的 性能损失就更大，对整个系统的性能影响也就更大了。

系统架构及实现性能影响:
   一个应用系统，Web程序（Web App）和应用程序服务器web server:tomcat,机器)。web server是使用成熟产品，能做的是通过一些简单的参数设置调整来进行调优，
   Web App是根据业务需求自行开发，可控性要好很多。所以从Web应用程序着手分析一个应用程序架构的不同设计对整个系统性能的影响
   系统架构决定了我们系统的构建环境。像建房子一样，清楚房子用途后，会先有建筑设计师来画出基本的造型图，然后还需要结构设计师为我们设计出结构图。
   系统架构设计的过程就和结构工程设计结构图一样，为整个系统搭建出一个尽可能最优的框架，让整个系统能够有一个稳定高效的结构体系让我们实现各种商业需求。
   考虑数据层面相关的架构：
       我们数据库中存放的数据都适合在数据库中存放的吗？大文本、流水队列数据不适合，是否错误的使用了数据库的很多并不是太擅长或者对性能影响很大的功能，
       利用缓存机制cache活跃数据和很少变化的数据：
          1. 系统各种配置及规则数据；配置信息变动的频率非常低，访问概率又很高，适合使用Cache； 
          2. 活跃用户的基本信息数据；很少有用户每天没事干去将自己的基本信息改来改去。且用户的基本信息在应用系统中的访问频率极其频繁。
          3. 活跃用户的个性化定制信息数据；对 Cache 技术的合理利用和扩充造就了项目整体的成功。
          4. 准实时的统计信息数据；就是基于时间段的统计数据。这种数据不会实时更新，当达到重新 Build 该统计数据的时候需要做一次全量更新操作。
          5. 其他一些访问频繁但变更较少的数据；各种系统环境中还会有各种各样的变更较少但是访问很频繁的数据。我们都可以将对他们的访问从数据库移到Cach中。
       我们的数据层实现都是最精简的吗？：
          合理的数据存取实现和拙劣的实现相比，在性能方面的差异会很大。分析一个非常简单且经常会遇到类似情况的示例
          对两个方案做一下简单的比较： 
          一：SELECT id,subject,url FROM photo WHERE user_id = ? limit 10
             再循环十次SELECT COUNT(*) FROM photo_comment WHERE photh_id = ?
          二：SELECT id,subject,url FROM photo WHERE user_id = ? limit 10拼装10个photo的id，
             再in查询SELECT photo_id,count(*) FROM photo_comment WHERE photo_id in (?) GROUP BY photo_id
              1、从 MySQL 执行的 SQL 数量看 ，第一种解决方案为 11（1+10=11）条 SQL 语句，第二种解决方案 为 2 条 SQL 语句（1+1）;
              2、从应用程序与数据库交互看，第一种为 11 次，第二种为 2 次； 
              3、从数据库的IO操作看，简单假设每次SQL为1 个IO，第一种最少11次 IO，第二种小于等于11 次 IO，只有当数据非常之离散情况下才需要11 次；
              4、从数据库处理的查询复杂度来看，第一种为两类很简单的查询，第二种有一条 SQL 语句有 GROUP BY 操作，比第一种解决方案增加了了排序分组操作；
              5、从应用程序结果集处理来看，第一种11次结果集的处理，第二中2次结果集的处理，但是第二种 解决方案中第二词结果处理数量是第一次的 10 倍；
              6、从应用程序数据处理来看，第二种比第一种多了一个拼装 photo_id 的过程。
              我们从6点来做一个性能消耗的分析： 
               1、MySQL对每次提交的SQL都需要进行完全解析，主要消耗资源是数据库主机CPU，第一种方案和第二种方案消耗CP的比例是11:2
               2、应用程序与数据库交互所消耗的资源基本上都在网络方面，同样也是 11：2； 
               3、数据库 IO 操作资源消耗为小于或者等于 1：1； 
               4、第二种解决方案需要比第一种多消耗内存资源进行排序分组操作，消耗由数据量决定可以针对性测试； 
               5、结果集处理次数也为 11：2，但是第二中解决方案第二次处理数量较大，整体来说两次的性能消 耗区别不大；
               6、应用程序数据处理方面所多出的这个photo_id 的拼装所消耗的资源是非常小。
            以对象为中心的思考方式来解决问题加强优化意识，sql优化，归结为过渡依赖嵌套循环的使用或者过渡弱化SQ语句的功能造成性能消耗过多
            过度依赖数据库SQL语句的功能造成数据库操作效率低下





