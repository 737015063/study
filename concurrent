上下文切换：cpu时间片
          减少上下文切换（减少阻塞等待）
              1无锁并发，取模处理数据
              2cas减少线程阻塞
              3减少线程数
              4协程
死锁：避免同时获取多个锁
      避免占用多个资源
      使用带超时的lock
      请求锁的顺序要相同
资源限制：硬件资源限制如带宽，磁盘，cpu,软件资源限制：数据库连接，socket连接等
            在cpu线程充足串行的部分改为并行
            解决硬件资源用集群，软件资源用复用
            
并发机制：一来jvm实现和cpu指令
    volatile原理应用：保证变量可见性，不会引起线程上下文切换和调度
                  内存屏障
                  1lock前缀指令引起处理器将缓存写回内存，锁总线或内存
                  将当前处理器的缓存写回内存
                  2使其他处理器缓存了该缓存行的数据失效
                  volatile优化:追加字节到64
    synchronized:实现同步基础：每个java对象都可以作为锁
                  monitorenter与monitorexist
        java对象头：hash码，分代年龄，锁标记
        锁的升级：偏向锁：降低获取锁的代价，出现竞争撤销偏向锁
                 轻量级锁：没获得自旋
    原子操作的实现原理：处理器通过总线和缓存锁定实现原子操作
                      java通过cas和锁实现原子操作，cas有aba问题和循环开销可能大
    java内存模型：
           内存模型基础：两个问题(共享内存和消息）通信，同步
                        jmm的抽象结构：主内存与线程本地内存，通过主内存和线程本地内存交互保证可见性
                        重排序：编译器和处理器重排序
                                jmm重排序规则会禁止特定类型的编译器和处理器重排序（通过内存屏障）
                        并发编程模型分类：写缓冲区临时保存写入内存的数据，批量与合并写入；写缓冲，读内存（首次）与缓冲
                                        现代处理器由于使用写缓冲区允许写读操作重排序，storeload会把写缓冲刷会内存，存在数据依赖不重排；
                        happen-before:一个操作对另一个操作可见存在happen-before关系
                                      程序的操作happen-before后续的操作
                                      解锁先于后续对这个锁的加锁
                                      volatile的写先于后续的读
                                      传递性规则  （后续两个字）
                                      要求前一个操作的结果对后可见，执行顺序不一定
                                      一个happen-before对应一个或多个编译器和处理器重排序规则
重排序：编译器和处理器重排序没数据依赖的指令
          数据依赖性：不重排
          as-if语义：随便排保证单线程执行的正确性
          程序顺序规则：happen-before
          重排序对多线程的影响：
顺序一致性: 数据竞争：一个线程写另一个读且没有同步
                    总线控制处理器串行访问内存
          顺序一致性模型：顺序执行，原子操作且对线程可见，是理论参考模型
          同步程序的顺序一致性：锁内可重排序
volatile特性：原子性
             可见性
   volatile写读建立的happen-before关系
   volatile写读的内存语义：写会把当前的线程的共享变量刷新到内存；读：会把当前线程的共享变量置为无效，强制从内存读
   volatile的内存语义的实现：通过内存屏障禁止重排序
   
锁释放获取建立happen-before关系，
锁的获取（内存语义）与volatile读一样从主内存读；锁的释放和volatile写一样写回内存
          利用volatile写读语义和cas附带的volatil写读语义
          释放锁的最后写volatile变量state对后续获取的线程可见，获取锁读volatile变量
          volatile写前读后不能重排序
          lock前缀指令具有内存屏障效果，禁止重排与刷新到内存
          
          concurrent包实现：volatile与cas实现同步
final域的内存语义：
          final的重排序：在构造器中对final的写，与随后将构造的对象赋给其他引用不能重排，return前storestore屏障实现，使用对象前构造器的final域赋值已初始化完成
                        对对象引用的访问，与对象内的final域的访问不能重排；读前loadload实现，读final域前，确保先读该对象的引用
                        对象引用不能溢出构造函数
happen-before：jmm设计：禁止改变程序结果的重排，不改变可以重排保证正确同步的结果
          a happen-before b即a对b可见 
happen-before规则：程序顺序（as-if语义），锁，volatile，传递性，线程start，线程join
          volatile双重锁定（分配内存，初始化，内存地址赋给变量不能重排）和基于类初始化的单例（初始化锁同步多个线程初始化类）
初始化类：创建实例，访问静态方法，赋值静态变量，使用静态变量
内存模型越弱束缚越少

线程：线程状态
      线程中断标志与安全终止   谁等调countdown.await,准备好countdown.countdown
      线程间通信：volatile使读内存，写同步回内存；synchronize
                    等待通知机制：同步队列，等待队列
                              通知方：获取锁-改变条件-进行通知
                              等待方：循环检查条件-是否等待或执行
                              thread.join
                    超时等待机制：
                    数据库连接池：初始化连接，由linkedlist容器维护连接个数
                                 获取连接与等待或超时返回，与释放连接通知
                    线程池：（数据和其他属性）线程容器，任务容器
                            （方法功能）即维护任务容器，维护线程容器（对其curd），
                              表示线程(worker)和任务（job）的类，(基本的对象）
                              工作线程不断循环处理job，没job则wait
                              
锁：lock：显示获取释放，可中断会抛异常释放锁，可超时获取不到返回
队列同步器AQS：定义同步状态的获取和释放；提供同步状态管理，线程排队，等待和唤醒；基于模板方法实现需继承并重写方法
              独占与共享获取释放锁
              同步队列：同步器：head，tail,节点，通过cas设置尾节点，fifo，首节点是获取到同步状态的节点，释放同步状态会唤醒后继节点
                       设置首节点通过获取到同步状态的线程来完成
                    
                    
                    
