上下文切换：cpu时间片
          减少上下文切换（减少阻塞等待）
              1无锁并发，取模处理数据
              2cas减少线程阻塞
              3减少线程数
              4协程
死锁：避免同时获取多个锁
      避免占用多个资源
      使用带超时的lock
      请求锁的顺序要相同
资源限制：硬件资源限制如带宽，磁盘，cpu,软件资源限制：数据库连接，socket连接等
            在cpu线程充足串行的部分改为并行
            解决硬件资源用集群，软件资源用复用
            
并发机制：一来jvm实现和cpu指令
    volatile原理应用：保证变量可见性，不会引起线程上下文切换和调度
                  内存屏障
                  1lock前缀指令引起处理器将缓存写回内存，锁总线或内存
                  将当前处理器的缓存写回内存
                  2使其他处理器缓存了该缓存行的数据失效
                  volatile优化:追加字节到64
    synchronized:实现同步基础：每个java对象都可以作为锁
                  monitorenter与monitorexist
        java对象头：hash码，分代年龄，锁标记
        锁的升级：偏向锁：降低获取锁的代价，出现竞争撤销偏向锁
                 轻量级锁：没获得自旋
    原子操作的实现原理：处理器通过总线和缓存锁定实现原子操作
                      java通过cas和锁实现原子操作，cas有aba问题和循环开销可能大
    java内存模型：
           内存模型基础：两个问题(共享内存和消息）通信，同步
                        jmm的抽象结构：主内存与线程本地内存，通过主内存和线程本地内存交互保证可见性
                        重排序：编译器和处理器重排序
                                jmm重排序规则会禁止特定类型的编译器和处理器重排序（通过内存屏障）
                        并发编程模型分类：写缓冲区临时保存写入内存的数据，批量与合并写入；写缓冲，读内存（首次）与缓冲
                                        现代处理器由于使用写缓冲区允许写读操作重排序，storeload会把写缓冲刷会内存，存在数据依赖不重排；
                        happen-before:一个操作对另一个操作可见存在happen-before关系
                                      程序的操作happen-before后续的操作
                                      解锁先于后续对这个锁的加锁
                                      volatile的写先于后续的读
                                      传递性规则  （后续两个字）
                                      要求前一个操作的结果对后可见，执行顺序不一定
                                      一个happen-before对应一个或多个编译器和处理器重排序规则
重排序：编译器和处理器重排序没数据依赖的指令
          数据依赖性：不重排
          as-if语义：随便排保证执行的正确性
          程序顺序规则：happen-before
          重排序对多线程的影响：
顺序一致性: 总线控制处理器串行访问内存
