利用多核，并行运算；单核时间片切换执行

jvm内存结构：
  1.程序计数器：看作线程私有执行字节码的行号指示器，改变值（地址）来取下一条指令，不会outofmemory
  2.Java栈：线程私有和伴随线程的生命周期，
            描述方法执行内存模型：执行方法创建栈帧（入栈）：存储局部变量表，操作数栈，动态链接，方法入口出口信息；执行完出栈
            局部变量表：存储boolean,char,byte,short,int,long,float,double基本类型和对象引用，内存空间在编译期确定
            超出栈允许的深度会抛出stackoverflow;允许扩展时申请不到足够内存会抛outofmemory        
  3.本地方法栈：与java栈类似，服务的方法不一样
  4.java堆：所有线程共享的区域，存放对象实例，垃圾收集器的管理区域，新生代（Eden,from survivor,to survivor）和老年代;
            更快的分配与回收策略，可以物理上不连续逻辑上连续，可扩展由-Xmx和-Xms控制，不够内存分配对象，也无法扩展内存抛outofmemory
  5.方法区（元空间）:线程共享，存放加载的类信息、常量、静态变量；垃圾收集器在方法区对常量池回收和类卸载，无法满足内存分配的需求outofmemory
            运行时常量池是方法区的一部分；class文件：版本，字段，方法，接口，常量池
  #6.直接内存：nio基于channel和bytebuffer可以申请堆外内存，用directbytebuffer引用，受物理机内存限制

对象创建：（new，clone，序列化，反射），规整的指针碰撞算法，有碎片的空闲列表（虚拟机维护）算法，垃圾收集器有compact的用指针碰撞，CMS标记清除用空闲列表
          对象创建频繁，创建过程线程不安全的：两种解决方案：1.采用cas同步和失败重试的方式；
                                                        2.线程在本线程的缓冲区进行分配（每个线程预先在java堆分配的一小块内存），用完才需同步
          会赋默认初始值
