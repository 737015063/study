利用多核，并行运算；单核时间片切换执行

jvm内存结构：
  1.程序计数器：看作线程私有执行字节码的行号指示器，改变值（地址）来取下一条指令，不会outofmemory
  2.Java栈：线程私有和伴随线程的生命周期，
            描述方法执行内存模型：执行方法创建栈帧（入栈）：存储局部变量表，操作数栈，动态链接，方法入口出口信息；执行完出栈
            局部变量表：存储boolean,char,byte,short,int,long,float,double基本类型和对象引用，内存空间在编译期确定
            超出栈允许的深度会抛出stackoverflow;允许扩展时申请不到足够内存会抛outofmemory        
  3.本地方法栈：与java栈类似，服务的方法不一样
  4.java堆：所有线程共享的区域，存放对象实例，垃圾收集器的管理区域，新生代（Eden,from survivor,to survivor）和老年代;
            更快的分配与回收策略，可以物理上不连续逻辑上连续，可扩展由-Xmx和-Xms控制，不够内存分配对象，也无法扩展内存抛outofmemory
  5.方法区（元空间）:线程共享，存放加载的类信息、常量、静态变量；垃圾收集器在方法区对常量池回收和类卸载，无法满足内存分配的需求outofmemory
            运行时常量池是方法区的一部分；class文件：版本，字段，方法，接口，常量池
  #6.直接内存：nio基于channel和bytebuffer可以申请堆外内存，用directbytebuffer引用，受物理机内存限制

对象创建：（new，clone，序列化，反射），规整的指针碰撞算法，有碎片的空闲列表（虚拟机维护）算法，垃圾收集器有compact的用指针碰撞，CMS标记清除用空闲列表
          对象创建频繁，创建过程线程不安全的：两种解决方案：1.采用cas同步和失败重试的方式；
                                                        2.线程在本线程的缓冲区进行分配（每个线程预先在java堆分配的一小块内存），用完才需同步
          会赋默认初始值，设置对象头信息：对象hash码，gc分代年龄，哪个类的实例，怎样找类的元信息，锁的状态，
          new之后init对象初始化完毕
          
对象内存布局：对象头：hash码，分代年龄，锁标志、持有锁的线程、偏向线程id、偏向时间戳，Mark word非固定的数据结构便于存储更多的数据或根据状态复用空间
                    类型指针：对象指向类元数据的指针；如果是数组对象头需要有一块记录数组长度的指针 
                                标志位         存储内容
                    未锁定状态：  01(2bit)            hash码（25bit），分代年龄(4bit)
                    轻量级锁      00                    指向锁记录的指针
                    重量级锁      10                    指向重量级锁的指针
                    gc标记       11                       空
                    可偏向       01                  线程的id,偏向时间戳，对象分代年龄
                    
            实例数据：在父类定义的会出现在子类之前
            对齐部分：占位符，对象起始位置须是8字节的整数倍，即对象大小是8的整数倍
            
对象访问定位：通过栈上的reference数据操作对象：指向（直接指针或句柄）对象的引用；
             两种实现方式：1.直接指针：速度快，减少了一次指针定位
                          1.句柄：存在堆上的句柄池，指向实例数据和类型数据的具体地址；（垃圾回收发生）对象移动时只需改句柄地址    
        
java堆溢出：不断创建对象，且GCRoot可达对象不被回收，到达内存限制就抛OOM；-XX:HeapDumpOnOutOfMemoryError:发生OOM转储内存堆快照，
           用内存映射分析工具eclipse Memory Analyzer打开dump文件:内存泄漏or内存溢出，定位泄漏对象到GCRoot引用链，查看导致无法回收的原因，定位代码位置
           不存在泄漏则，查看-Xmx和-Xms参数是否可以调大，缩短不必要的对象生命周期
           
java栈溢出： -Xss设定栈容量，Stack Overflow ：超过栈允许的深度抛
                           OOM:栈无法申请到空间，建立多线程可能会出现，通过减少堆和栈的大小换取线程数，java线程是映射到操作系统内核线程
                           
方法区和常量池溢出：-XX:PermSize;-XX:MaxPermSize;stirng.intern把改字符串放到常量池（如果常量池没有）并返回字符串，否则直接返回字符串
                  方法区存放类名，修饰符，常量，字段，方法，测试思路;产生大量的类(原因是存放类)
                  
直接内存溢出：是否是直接间接nio相关的使用导致，-XX:MaxDirectMemorySize设定否则和最大堆一样
