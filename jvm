利用多核，并行运算；单核时间片切换执行

jvm内存结构：
  1.程序计数器：看作线程私有执行字节码的行号指示器，改变值（地址）来取下一条指令，不会outofmemory
  2.Java栈：线程私有和伴随线程的生命周期，
            描述方法执行内存模型：执行方法创建栈帧（入栈）：存储局部变量表，操作数栈，动态链接，方法入口出口信息；执行完出栈
            局部变量表：存储boolean,char,byte,short,int,long,float,double基本类型和对象引用，内存空间在编译期确定
            超出栈允许的深度会抛出stackoverflow;允许扩展时申请不到足够内存会抛outofmemory        
  3.本地方法栈：与java栈类似，服务的方法不一样
  4.java堆：所有线程共享的区域，存放对象实例，垃圾收集器的管理区域，新生代（Eden,from survivor,to survivor）和老年代;
            更快的分配与回收策略，可以物理上不连续逻辑上连续，可扩展由-Xmx和-Xms控制，不够内存分配对象，也无法扩展内存抛outofmemory
  5.方法区（元空间）:线程共享，存放加载的类信息、常量、静态变量；垃圾收集器在方法区对常量池回收和类卸载，无法满足内存分配的需求outofmemory
            运行时常量池是方法区的一部分；class文件：版本，字段，方法，接口，常量池
  #6.直接内存：nio基于channel和bytebuffer可以申请堆外内存，用directbytebuffer引用，受物理机内存限制

对象创建：（new，clone，序列化，反射），规整的指针碰撞算法，有碎片的空闲列表（虚拟机维护）算法，垃圾收集器有compact的用指针碰撞，CMS标记清除用空闲列表
          对象创建频繁，创建过程线程不安全的：两种解决方案：1.采用cas同步和失败重试的方式；
                                                        2.线程在本线程的缓冲区进行分配（每个线程预先在java堆分配的一小块内存），用完才需同步
          会赋默认初始值，设置对象头信息：对象hash码，gc分代年龄，哪个类的实例，怎样找类的元信息，锁的状态，
          new之后init对象初始化完毕
          
对象内存布局：对象头：hash码，分代年龄，锁标志、持有锁的线程、偏向线程id、偏向时间戳，Mark word非固定的数据结构便于存储更多的数据或根据状态复用空间
                    类型指针：对象指向类元数据的指针；如果是数组对象头需要有一块记录数组长度的指针 
                                标志位         存储内容
                    未锁定状态：  01(2bit)            hash码（25bit），分代年龄(4bit)
                    轻量级锁      00                    指向锁记录的指针
                    重量级锁      10                    指向重量级锁的指针
                    gc标记       11                       空
                    可偏向       01                  线程的id,偏向时间戳，对象分代年龄
                    
            实例数据：在父类定义的会出现在子类之前
            对齐部分：占位符，对象起始位置须是8字节的整数倍，即对象大小是8的整数倍
            
对象访问定位：通过栈上的reference数据操作对象：指向（直接指针或句柄）对象的引用；
             两种实现方式：1.直接指针：速度快，减少了一次指针定位
                          1.句柄：存在堆上的句柄池，指向实例数据和类型数据的具体地址；（垃圾回收发生）对象移动时只需改句柄地址    
        
java堆溢出：不断创建对象，且GCRoot可达对象不被回收，到达内存限制就抛OOM；-XX:HeapDumpOnOutOfMemoryError:发生OOM转储内存堆快照，
           用内存映射分析工具eclipse Memory Analyzer打开dump文件:内存泄漏or内存溢出，定位泄漏对象到GCRoot引用链，查看导致无法回收的原因，定位代码位置
           不存在泄漏则，查看-Xmx和-Xms参数是否可以调大，缩短不必要的对象生命周期
                
java栈溢出： -Xss设定栈容量，Stack Overflow ：超过栈允许的深度抛
                           OOM:栈无法申请到空间，建立多线程可能会出现，通过减少堆和栈的大小换取线程数，java线程是映射到操作系统内核线程
                           
方法区和常量池溢出：-XX:PermSize;-XX:MaxPermSize;stirng.intern把改字符串放到常量池（如果常量池没有）并返回字符串，否则直接返回字符串
                  方法区存放类名，修饰符，常量，字段，方法，测试思路;产生大量的类(原因是存放类)
                  
直接内存溢出：是否是直接间接nio相关的使用导致，-XX:MaxDirectMemorySize设定否则和最大堆一样

引用计数法
可达性分析算法：
            gcroot:栈帧的本地变量引用的对象
                    常量引用的对象
                    静态变量引用的对象
                    jni引用的对象
            强引用：
            软引用：内存不够时回收
            弱引用：下次垃圾收集回收
            虚引用：接收通知
            回收需经过两次标记，第一次查看是否需调用finalize方法（只触发一次）进行筛选，第二次调用finalize过程被赋给其他变量可以避免被回收
            回收方法区：不被引用的常量和类
            
            垃圾收集：1标记清除：思路：先标记，在统一清除，其他的都是基于这进行改善的算法；有碎片，不够分配大对象会触发gc
                     2复制算法：把空间分半只用其中一般进行分配，回收时会把存活的复制到另一半，清除那半；
                        用来回收新生代，比例为8:1，回收会把eden和s0存活的复制到s1,还不够分配对象的话在老年代直接分配
                     3标记整理：先标记然后移到一端把端外的清除掉
                     4分代收集：新生代用复制，老年代用标记压缩或标记清除
                     
                     gc需要一致性的快照即回收时对象的引用不能发生变化，否则不准确；即stop the word 
                     oopMap记录gcroot引用，jit也会在栈和寄存器记录那些位置引用
                     
                     安全点：即并不是所有的点程序都能停下来gc，要到达安全点才能暂停如方法调用、循环、异常跳转
                            抢占式：暂停所有线程，不在安全点就恢复这个线程让它到安全点
                            主动式中断：在安全点设置标志，线程需检查标志是否为true
                     安全区域：代码段的位置都是安全引用关系不会变，任一点开始gc都可以，线程离开safe region时需检测gc是否完成，否则等待信号
                     
             垃圾收集器：1serial：单线程，会stop the word,简单高效，是client模式下新生代的默认回收器
                        2parNew:serial的多线程版本，server模式下的新生代首选与CMS配合使用
                        3parallel scavenge：和parnew差不多，主要吞吐量优先适合后台运算交互少，新生代小收集快，次数多吞吐量少（代码执行时间/总时间）
                                            可以设置-xx:useadaptersizepolicy让虚拟机调节新生代大小和比例，晋升老年代的年龄
                        4serial old:serial的老年代版本，是复制算法作为cms回收失败的后备回收器
                        5parallel old：parallel scavenge的老年代版本与新生代的parallel配合使用，适合吞吐大和cpu敏感的场合
                        6cms:为了缩短停顿，4步：1初始标记gcroot：会stop the word
                                              2并发标记：可达的；和用户线程并发运行
                                              3重标记：标记并发标记过程用户程序改变的引用
                                              4并发清除
                             优点：并发，停顿时间短
                             缺点：1cpu资源敏感，开启的回收线程（cpu+3）/4占用cpu,在cpu少会变慢
                                  2并发清除时会产生浮动垃圾，要下一次回收，用户线程在运行设置触发老年代空间回收的百分比
                                      需预留空间否则会conccurent mode failure触发serialold回收
                                  3会产生碎片，无法为大对象分配连续空间时，通过参数设置解决
                        7G1收集器：并行与并发缩短时间
                                  分代收集：能独立管理整个堆，用不同的策略回收新创建的和已存活一段时间的对象
                                  空间整合：整体是标记压缩，局部region是复制算法
                                  可预测的停顿时间:在M秒内的停顿时间不超过N秒
                                  
                                  分成大小相等的region，避免在全堆进行回收，跟踪region的回收价值（回收空间收益与时间成本），维护一个列表在允许的时间内
                                  回收价值最大的region，region之间的对象引用，通过rememberset来避免全堆扫描，进行写操作会检查reference引用的对象
                                  是否处在不同的region，是就把引用信息记录到被引用的对象所处的region的rememberset中，进行回收在gcroot枚举范围
                                  加入rememberset，避免全堆扫描也可保证不遗漏引用信息
                                  步骤和cms差不多：1初始标记：停顿线程让用户线程在正确的region产生对象
                                                  2并发标记
                                                  3最终标记：记录并发标记发生变化的记录到remembersetlogs并合并到rememberset
                                                  4筛选回收会对region回收价值进行排序
                                                  
gc日志：full gc会stop the word，发生的区域名有收集器决定
  对象优先分配到Eden区，空间不够触发minor gc,回收过程s1存不了会放到老年代，回收后还不够在老年代分配
  大对象直接分配到老年代，长存活的将进入老年代，由对象年龄设置决定默认15
  动态对象年龄判断
  空间分配担保

jps:虚拟机进程信息
jstat：虚拟机进程统计信息：类装载，内存垃圾收集运行期编译状况
jinfo:java配置信息：各项参数
jmap:内存映像工具
jhat:堆转储快照分析工具
jstack：堆栈跟踪工具生成线程快照分析时间长或者死锁死循环等
jconsole:监控和管理内存和线程
visualVM:all-in-one
        显示进程的配置和环境信息
        监视cpu，gc，堆方法区和线程信息
        dump及分析堆转储快照
        方法级的运行性能分析，找出被调用最多，运行最长的方法
        
        
jvm与class字节码文件关联而不与语言关联
    class文件包含java虚拟机指令集和符号表、辅助信息（强制语法和结构化约束）
    字节码命令
    编译器把源代码编译成class文件，jvm读取运行

class类文件的结构：一组8位字节为基础单位的二进制流
  每个class文件的头4字节称为魔数紧接着的4字节是class文件版本号，版本号后紧接着常量池，常量池结束后是访问标志（access_flags)，
  类索引和父类索引和接口集合索引按序排在访问标志后，字段表集合，方法表集合ACC_SYNCHRONIZED,属性表集合，方法会编译成指令存在code属性里，
  max_stack栈最多深度，max_locals是局部变量表的空间32位的slot为单位可重用，实例方法的局部变量表会有一个执行当前实例的参数，
  
  jvm指令：操作码范围：一个字节长度0~255，操作数跟随在操作码后，大多指令包含了操作的数据类型信息，加载和存储指令，运算指令，类型转换指令
           对象创建与访问指令，操作数栈管理指令，控制转移指令，方法调用和返回指令，异常处理指令，同步指令（monitor支持），
           同步方法通过ACC_synchronize实现，指令集monitorenter和monitorexit支持
           
类加载机制：class加载到内存，校验、解析、初始化变成虚拟机使用的java类型，如运行时指定实现类
          生命周期：加载、连接（验证，准备、解析）、初始化、使用、卸载
          使用new、读取设置静态类属性，调用类的静态方法、反射调用、
          
          类加载过程：加载阶段：1全限定名获取类的二进制字节流
                              2字节流的静态结构转化成方法区运行时数据结构
                              3内存中生成代表类的java.lang.Class对象
                     验证阶段：确保class文件的信息符合要求，解析存储于方法区，符合描述一个java类型的格式
                              1文件格式验证：是否以魔数开头、主次版本号是否在虚拟机范围、常量池是否有不被支持的类型、指向常量的索引是否有指向不存在的
                                常量，constant_utf8_info型的常量是否有不符合utf8的编码数据、class文件是否有被删除和附加的部分
                              2元数据验证：信息符合java规范的要求
                                          1是否继承了final类型的类，不是抽象类是否实现父类或接口要求的方法，是否赋给父类final字段，重载方法是否合法
                              3字节码检验：保证执行不能跳转到方法体外，类型转换是有效的
                              4符号引用验证：引用字符串的全限定名能否找到类，方法和字段或抛出nosuchfield、nosuchmethod异常-XVerify:none跳过验证
                                            符号中引用的类、字段、方法的访问性（public）是否可被当前类访问
                     准备阶段：为类变量分配内存，赋初始零值，final的赋初始值、
                     
                     解析阶段：符号引用替换为直接引用，符号引用：符号所引用的目标，直接引用：指向目标的指针
                              1类或接口解析:在某个类中加载解析调用的类
                              2字段解析：查找某个类或父级是否存在字段简单名称，和访问权限
                              3接口解析,方法解析与字段解析类似
                     初始化阶段：类加载的最后一步，初始化代码，静态代码块，静态变量等，会锁定同步
         类加载器：不同的类加载器有命名空间区分
         双亲委派模型:类加载器接收到一个类加载请求会把请求交给父加载器父加载器无法加载在尝试自己加载
         线程上下文类加载器(默认是应用程序类加载器)破坏双亲委派，

执行引擎：解释执行和编译执行
         栈帧：方法执行数据结构
              1局部变量表：slot，局部变量要赋值才能使用
              2操作数栈：会重叠一部分操作数栈优化
              3动态链接：指向所属方法的引用
              4方法返回地址
         方法调用：解析
                  分派：静态分派（重载），动态分派（重写）

字节码生成技术和动态代理实现


javac编译器：把.java编译成,class文件;编译优化字符串拼接，无返回值或返回值一样时不能重载只有list<string>与list<integer>参数的方法 
语法糖：泛型与类型擦除，自动装箱拆箱，foreach,变长参数，条件编译，内部类，枚举类，断言，switch
虚拟机把频繁执行的方法和代码块编译成本地机器码优化
解释器：启动执行快，省去编译时间 
编译器：编译代码占用程序运时间，提高频繁运行代码（循环与多次调用的方法）的效率
编译对象与触发条件：采样探测：周期性的检查各个线程的栈顶，经常出现在栈顶的方法
                   计数探测：为方法建立并维护计数器，超过（设定）阈值的方法
                   已编译会执行编译后的机器码，否则解释执行计数增加
                   计数器会热度衰减 -XX:UseCounterDecay关闭衰减
编译过程：无用代码消除表达式外提，检查消除，重排序，方法内联减少方法访问成本（建立栈帧），在更大范围采取后续优化

编译优化：公共子表达式消除
          数组边界检查消除
          方法内联
          逃逸分析
硬件的效率与一致性：处理器内存的速度矛盾利用高速缓存来解决，存在更新内存的一致性问题
tps:服务器每秒平均响应的请求总数
内存模型：定义变量的访问规则：存与取
      主内存存储变量与工作内存读取操作变量副本
 原子命令：lock:把主内存变量标识为一个线程独占状态
          unlock:解锁锁定的主内存变量
          read:把主内存的变量传输到工作内存
          load:read的内存变量放入工作内存变量副本中
          use：执行引擎使用工作内存变量
          assign：把执行引擎返回的值赋给工作变量副本
          store:把工作内存变量传送到主内存
          write:得到的变量放入主内存变量中；
          
          read,load、store，write不允许单独出现
          工作内存变量assign变了必须同步回主内存
          没发生assgin不允许同步回主内存
          新变量只能从主内存产生
          一个变量同一时刻只能有一个线程lock
          对变量执行lock会清空工作内存此变量的值
          先lock才能unlock
          unlock前把变量写回主内存
          
volatile访问规则：1.保证变量对所有线程的可见性
                  运算结果不依赖当前的值
                  2.禁止指令重排序，lock指令，相当于内存屏障，作用相当于把变量写入内存使其他cpu的cache失效
                  use前先load，load后use，read；assign后是store，store前是assign
                  
原子性:synchronized,8个原子命令
可见性:volatile，synchronized，final
有序性：synchronized，volatile
先行发生原则：(A发生于B前B能看到A的结果)
            程序次序原则：一个线程内，代码执行有序
            管程（monitor）锁定原则：一个unlock先行与后续对这个锁的lock
            volatile原则：对volatile的写先于后续对变量的读
            线程启动原则：线程start先于线程内的执行操作
            线程终止原则：线程的操作先于线程的终止检测
            线程中断原则：interrupt先行于被检查到中断的代码
            对象终结原则：对象的初始化先行finalize
            传递性原则：a先于b，b先于c，则a先于c
            时间先后顺序与先行原则没关系，并发安全以先行原则为准，不要受时间顺序影响
          
线程:比进程更轻量级的调度单位
内核线程实现：内核线程的高级接口：轻量级进程实现；消耗内核资源，内核态和用户态切换代价大
用户线程实现：不是建立在内核线程之上的线程
用户线程和轻量级进程混合实现：用户线程(用户态创建切换代价小)和轻量级进程（负责和内核线程交互）N对M，（linuxWindows1对1线程模型）
java线程调度：抢占式（分配cpu时间，yield方法可以让出），协同式由线程执行完切换
线程状态转换：新建new尚未启动；
             running等待cpu或正在运行
             wait:无限期等待，需要其他线程唤醒，不分配cpu时间，object.wait，thread.join,locksupport.lock
             timewaiting:有限期等待一定时间后系统自动唤醒，sleep，object.wait(time),locksupport.parknano
             blocked：阻塞状态，等待其他线程释放锁
线程安全:不可变；final修饰状态变量使其不可变，要么生成新对象如string
        绝对线程安全，多线程操作数组会抛异常
        相对线程安全：vector，hashtable等单独调用安全，多线程下在调用方需同步
        线程兼容：ArrayList，hashmap等，调用端需同步
        
线程安全的实现方法：
                  1.互斥同步，synchronized,monitorenter,monitorexit;阻塞唤醒需进行用户态和内核态切换耗时间，用自旋等待优化；reentrantlock
                  可中断：持有锁的线程长时间不释放锁，等待线程可以放弃等待；公平性：按照申请锁的时间来依次获得锁；锁绑定多个条件
                  2.非阻塞同步：乐观锁策略，先操作没有争用成功，有冲突补偿策略：不断重试；不挂起线程，非阻塞
                    一条处理器指令就能完成看起来需要多次操作的行为：测试并设置（test-and-set）
                                                                获取并增加（fetch-and-increate）
                                                                交换（swap）
                                                                比较并交换（compare-and-swap:cas）
                                                                加载链接/条件存储（LL/SC）
                    ABA问题：atomicstampedreference或互斥同步
                  3.无同步方案：可重入；线程本地存储：队列消费者模式
                  
  锁优化：自旋锁：自旋默认10次，锁定时间短效果好，长浪费cpu；自适应自旋根据上次获得锁的自旋时间，是否成功
          锁消除：根据逃逸分析是否会逃逸出方法
          锁粗化：把连续的加锁解锁粗化成一次加解锁
          轻量级锁：进入同步块时，同步对象没有被锁定，在栈帧复制Mark word cas更新对象头为指向栈帧上的Mark word，锁状态更新为00；更新失败的话查看是否
                    指向当前线程，否则是给其他线程占了，升级为重量级锁，锁状态变为10Mark word存储指向重量级锁的指针，后面线程阻塞；
                    适用于同步周期不存在锁竞争的情况，使用cas避免互斥量的开销，否则开销更多；解锁把mark word替换回来，替换失败则有其他线程尝试获取锁
          偏向锁：第一次进入且开启偏向会记录线程id，后面有其他的线程尝试获取会撤销偏向，改为未锁定或（锁定状态）轻量级锁
          
          
          
          
          
