利用多核，并行运算；单核时间片切换执行

jvm内存结构：
  1.程序计数器：看作线程私有执行字节码的行号指示器，改变值（地址）来取下一条指令，不会outofmemory
  2.Java栈：线程私有和伴随线程的生命周期，
            描述方法执行内存模型：执行方法创建栈帧（入栈）：存储局部变量表，操作数栈，动态链接，方法入口出口信息；执行完出栈
            局部变量表：存储boolean,char,byte,short,int,long,float,double基本类型和对象引用，内存空间在编译期确定
            超出栈允许的深度会抛出stackoverflow;允许扩展时申请不到足够内存会抛outofmemory        
  3.本地方法栈：与java栈类似，服务的方法不一样
  4.java堆：所有线程共享的区域，存放对象实例，垃圾收集器的管理区域，新生代（Eden,from survivor,to survivor）和老年代;
            更快的分配与回收策略，可以物理上不连续逻辑上连续，可扩展由-Xmx和-Xms控制，不够内存分配对象，也无法扩展内存抛outofmemory
  5.方法区（元空间）:线程共享，存放加载的类信息、常量、静态变量；垃圾收集器在方法区对常量池回收和类卸载，无法满足内存分配的需求outofmemory
            运行时常量池是方法区的一部分；class文件：版本，字段，方法，接口，常量池
  #6.直接内存：nio基于channel和bytebuffer可以申请堆外内存，用directbytebuffer引用，受物理机内存限制

对象创建：（new，clone，序列化，反射），规整的指针碰撞算法，有碎片的空闲列表（虚拟机维护）算法，垃圾收集器有compact的用指针碰撞，CMS标记清除用空闲列表
          对象创建频繁，创建过程线程不安全的：两种解决方案：1.采用cas同步和失败重试的方式；
                                                        2.线程在本线程的缓冲区进行分配（每个线程预先在java堆分配的一小块内存），用完才需同步
          会赋默认初始值，设置对象头信息：对象hash码，gc分代年龄，哪个类的实例，怎样找类的元信息，锁的状态，
          new之后init对象初始化完毕
          
对象内存布局：对象头：hash码，分代年龄，锁标志、持有锁的线程、偏向线程id、偏向时间戳，Mark word非固定的数据结构便于存储更多的数据或根据状态复用空间
                    类型指针：对象指向类元数据的指针；如果是数组对象头需要有一块记录数组长度的指针 
                                标志位         存储内容
                    未锁定状态：  01(2bit)            hash码（25bit），分代年龄(4bit)
                    轻量级锁      00                    指向锁记录的指针
                    重量级锁      10                    指向重量级锁的指针
                    gc标记       11                       空
                    可偏向       01                  线程的id,偏向时间戳，对象分代年龄
                    
            实例数据：在父类定义的会出现在子类之前
            对齐部分：占位符，对象起始位置须是8字节的整数倍，即对象大小是8的整数倍
            
对象访问定位：通过栈上的reference数据操作对象：指向（直接指针或句柄）对象的引用；
             两种实现方式：1.直接指针：速度快，减少了一次指针定位
                          1.句柄：存在堆上的句柄池，指向实例数据和类型数据的具体地址；（垃圾回收发生）对象移动时只需改句柄地址    
        
java堆溢出：不断创建对象，且GCRoot可达对象不被回收，到达内存限制就抛OOM；-XX:HeapDumpOnOutOfMemoryError:发生OOM转储内存堆快照，
           用内存映射分析工具eclipse Memory Analyzer打开dump文件:内存泄漏or内存溢出，定位泄漏对象到GCRoot引用链，查看导致无法回收的原因，定位代码位置
           不存在泄漏则，查看-Xmx和-Xms参数是否可以调大，缩短不必要的对象生命周期
           
java栈溢出： -Xss设定栈容量，Stack Overflow ：超过栈允许的深度抛
                           OOM:栈无法申请到空间，建立多线程可能会出现，通过减少堆和栈的大小换取线程数，java线程是映射到操作系统内核线程
                           
方法区和常量池溢出：-XX:PermSize;-XX:MaxPermSize;stirng.intern把改字符串放到常量池（如果常量池没有）并返回字符串，否则直接返回字符串
                  方法区存放类名，修饰符，常量，字段，方法，测试思路;产生大量的类(原因是存放类)
                  
直接内存溢出：是否是直接间接nio相关的使用导致，-XX:MaxDirectMemorySize设定否则和最大堆一样

引用计数法
可达性分析算法：
            gcroot:栈帧的本地变量引用的对象
                    常量引用的对象
                    静态变量引用的对象
                    jni引用的对象
            强引用：
            软引用：内存不够时回收
            弱引用：下次垃圾收集回收
            虚引用：接收通知
            回收需经过两次标记，第一次查看是否需调用finalize方法（只触发一次）进行筛选，第二次调用finalize过程被赋给其他变量可以避免被回收
            回收方法区：不被引用的常量和类
            
            垃圾收集：1标记清除：思路：先标记，在统一清除，其他的都是基于这进行改善的算法；有碎片，不够分配大对象会触发gc
                     2复制算法：把空间分半只用其中一般进行分配，回收时会把存活的复制到另一半，清除那半；
                        用来回收新生代，比例为8:1，回收会把eden和s0存活的复制到s1,还不够分配对象的话在老年代直接分配
                     3标记整理：先标记然后移到一端把端外的清除掉
                     4分代收集：新生代用复制，老年代用标记压缩或标记清除
                     
                     gc需要一致性的快照即回收时对象的引用不能发生变化，否则不准确；即stop the word 
                     oopMap记录gcroot引用，jit也会在栈和寄存器记录那些位置引用
                     
                     安全点：即并不是所有的点程序都能停下来gc，要到达安全点才能暂停如方法调用、循环、异常跳转
                            抢占式：暂停所有线程，不在安全点就恢复这个线程让它到安全点
                            主动式中断：在安全点设置标志，线程需检查标志是否为true
                     安全区域：代码段的位置都是安全引用关系不会变，任一点开始gc都可以，线程离开safe region时需检测gc是否完成，否则等待信号
                     
             垃圾收集器：1serial：单线程，会stop the word,简单高效，是client模式下新生代的默认回收器
                        2parNew:serial的多线程版本，server模式下的新生代首选与CMS配合使用
                        3parallel scavenge：和parnew差不多，主要吞吐量优先适合后台运算交互少，新生代小收集快，次数多吞吐量少（代码执行时间/总时间）
                                            可以设置-xx:useadaptersizepolicy让虚拟机调节新生代大小和比例，晋升老年代的年龄
                        4serial old:serial的老年代版本，是复制算法作为cms回收失败的后备回收器
                        5parallel old：parallel scavenge的老年代版本与新生代的parallel配合使用，适合吞吐大和cpu敏感的场合
                        6cms:为了缩短停顿，4步：1初始标记gcroot：会stop the word
                                              2并发标记：可达的；和用户线程并发运行
                                              3重标记：标记并发标记过程用户程序改变的引用
                                              4并发清除
                             优点：并发，停顿时间短
                             缺点：1cpu资源敏感，开启的回收线程（cpu+3）/4占用cpu,在cpu少会变慢
                                  2并发清除时会产生浮动垃圾，要下一次回收，用户线程在运行设置触发老年代空间回收的百分比
                                      需预留空间否则会conccurent mode failure触发serialold回收
                                  3会产生碎片，无法为大对象分配连续空间时，通过参数设置解决
                        7G1收集器：并行与并发缩短时间
                                  分代收集：能独立管理整个堆，用不同的策略回收新创建的和已存活一段时间的对象
                                  空间整合：整体是标记压缩，局部region是复制算法
                                  可预测的停顿时间:在M秒内的停顿时间不超过N秒
                                  
                                  分成大小相等的region，避免在全堆进行回收，跟踪region的回收价值（回收空间收益与时间成本），维护一个列表在允许的时间内
                                  回收价值最大的region，region之间的对象引用，通过rememberset来避免全堆扫描，进行写操作会检查reference引用的对象
                                  是否处在不同的region，是就把引用信息记录到被引用的对象所处的region的rememberset中，进行回收在gcroot枚举范围
                                  加入rememberset，避免全堆扫描也可保证不遗漏引用信息
                                  步骤和cms差不多：1初始标记：停顿线程让用户线程在正确的region产生对象
                                                  2并发标记
                                                  3最终标记：记录并发标记发生变化的记录到remembersetlogs并合并到rememberset
                                                  4筛选回收会对region回收价值进行排序
                                                  
gc日志：full gc会stop the word，发生的区域名有收集器决定
  对象优先分配到Eden区，空间不够触发minor gc,回收过程s1存不了会放到老年代，回收后还不够在老年代分配
  大对象直接分配到老年代，长存活的将进入老年代，由对象年龄设置决定默认15
  动态对象年龄判断
  空间分配担保

jps:虚拟机进程信息
jstat：虚拟机进程统计信息：类装载，内存垃圾收集运行期编译状况
jinfo:java配置信息：各项参数
jmap:内存映像工具
jhat:堆转储快照分析工具
jstack：堆栈跟踪工具生成线程快照分析时间长或者死锁死循环等
