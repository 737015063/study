利用多核，并行运算；单核时间片切换执行

jvm内存结构：
  1.程序计数器：看作线程私有执行字节码的行号指示器，改变值（地址）来取下一条指令，不会outofmemory
  2.Java栈：线程私有和伴随线程的生命周期，
            描述方法执行内存模型：执行方法创建栈帧（入栈）：存储局部变量表，操作数栈，动态链接，方法入口出口信息；执行完出栈
            局部变量表：存储boolean,char,byte,short,int,long,float,double基本类型和对象引用，内存空间在编译期确定
            超出栈允许的深度会抛出stackoverflow;允许扩展时申请不到足够内存会抛outofmemory        
  3.本地方法栈：与java栈类似，服务的方法不一样
  4.java堆：所有线程共享的区域，存放对象实例，垃圾收集器的管理区域，新生代（Eden,from survivor,to survivor）和老年代;
            更快的分配与回收策略，可以物理上不连续逻辑上连续，可扩展由-Xmx和-Xms控制，不够内存分配对象，也无法扩展内存抛outofmemory
  5.方法区（元空间）:线程共享，存放加载的类信息、常量、静态变量；垃圾收集器在方法区对常量池回收和类卸载，无法满足内存分配的需求outofmemory
            运行时常量池是方法区的一部分；class文件：版本，字段，方法，接口，常量池
  #6.直接内存：nio基于channel和bytebuffer可以申请堆外内存，用directbytebuffer引用，受物理机内存限制

对象创建：（new，clone，序列化，反射），规整的指针碰撞算法，有碎片的空闲列表（虚拟机维护）算法，垃圾收集器有compact的用指针碰撞，CMS标记清除用空闲列表
          对象创建频繁，创建过程线程不安全的：两种解决方案：1.采用cas同步和失败重试的方式；
                                                        2.线程在本线程的缓冲区进行分配（每个线程预先在java堆分配的一小块内存），用完才需同步
          会赋默认初始值，设置对象头信息：对象hash码，gc分代年龄，哪个类的实例，怎样找类的元信息，锁的状态，
          new之后init对象初始化完毕
          
对象内存布局：对象头：hash码，分代年龄，锁标志、持有锁的线程、偏向线程id、偏向时间戳，Mark word非固定的数据结构便于存储更多的数据或根据状态复用空间
                    类型指针：对象指向类元数据的指针；如果是数组对象头需要有一块记录数组长度的指针 
                                标志位         存储内容
                    未锁定状态：  01(2bit)            hash码（25bit），分代年龄(4bit)
                    轻量级锁      00                    指向锁记录的指针
                    重量级锁      10                    指向重量级锁的指针
                    gc标记       11                       空
                    可偏向       01                  线程的id,偏向时间戳，对象分代年龄
                    
            实例数据：在父类定义的会出现在子类之前
            对齐部分：占位符，对象起始位置须是8字节的整数倍，即对象大小是8的整数倍
            
对象访问定位：通过栈上的reference数据操作对象：指向（直接指针或句柄）对象的引用；
             两种实现方式：1.直接指针：速度快，减少了一次指针定位
                          1.句柄：存在堆上的句柄池，指向实例数据和类型数据的具体地址；（垃圾回收发生）对象移动时只需改句柄地址    
        
java堆溢出：不断创建对象，且GCRoot可达对象不被回收，到达内存限制就抛OOM；-XX:HeapDumpOnOutOfMemoryError:发生OOM转储内存堆快照，
           用内存映射分析工具eclipse Memory Analyzer打开dump文件:内存泄漏or内存溢出，定位泄漏对象到GCRoot引用链，查看导致无法回收的原因，定位代码位置
           不存在泄漏则，查看-Xmx和-Xms参数是否可以调大，缩短不必要的对象生命周期
                
java栈溢出： -Xss设定栈容量，Stack Overflow ：超过栈允许的深度抛
                           OOM:栈无法申请到空间，建立多线程可能会出现，通过减少堆和栈的大小换取线程数，java线程是映射到操作系统内核线程
                           
方法区和常量池溢出：-XX:PermSize;-XX:MaxPermSize;stirng.intern把改字符串放到常量池（如果常量池没有）并返回字符串，否则直接返回字符串
                  方法区存放类名，修饰符，常量，字段，方法，测试思路;产生大量的类(原因是存放类)
                  
直接内存溢出：是否是直接间接nio相关的使用导致，-XX:MaxDirectMemorySize设定否则和最大堆一样

引用计数法
可达性分析算法：
            gcroot:栈帧的本地变量引用的对象
                    常量引用的对象
                    静态变量引用的对象
                    jni引用的对象
            强引用：
            软引用：内存不够时回收
            弱引用：下次垃圾收集回收
            虚引用：接收通知
            回收需经过两次标记，第一次查看是否需调用finalize方法（只触发一次）进行筛选，第二次调用finalize过程被赋给其他变量可以避免被回收
            回收方法区：不被引用的常量和类
            
            垃圾收集：1标记清除：思路：先标记，在统一清除，其他的都是基于这进行改善的算法；有碎片，不够分配大对象会触发gc
                     2复制算法：把空间分半只用其中一般进行分配，回收时会把存活的复制到另一半，清除那半；
                        用来回收新生代，比例为8:1，回收会把eden和s0存活的复制到s1,还不够分配对象的话在老年代直接分配
                     3标记整理：先标记然后移到一端把端外的清除掉
                     4分代收集：新生代用复制，老年代用标记压缩或标记清除
                     
                     gc需要一致性的快照即回收时对象的引用不能发生变化，否则不准确；即stop the word 
                     oopMap记录gcroot引用，jit也会在栈和寄存器记录那些位置引用
                     
                     安全点：即并不是所有的点程序都能停下来gc，要到达安全点才能暂停如方法调用、循环、异常跳转
                            抢占式：暂停所有线程，不在安全点就恢复这个线程让它到安全点
                            主动式中断：在安全点设置标志，线程需检查标志是否为true
                     安全区域：代码段的位置都是安全引用关系不会变，任一点开始gc都可以，线程离开safe region时需检测gc是否完成，否则等待信号
                     
             垃圾收集器：1serial：单线程，会stop the word,简单高效，是client模式下新生代的默认回收器
                        2parNew:serial的多线程版本，server模式下的新生代首选与CMS配合使用
                        3parallel scavenge：和parnew差不多，主要吞吐量优先适合后台运算交互少，新生代小收集快，次数多吞吐量少（代码执行时间/总时间）
                                            可以设置-xx:useadaptersizepolicy让虚拟机调节新生代大小和比例，晋升老年代的年龄
                        4serial old:serial的老年代版本，是复制算法作为cms回收失败的后备回收器
                        5parallel old：parallel scavenge的老年代版本与新生代的parallel配合使用，适合吞吐大和cpu敏感的场合
                        6cms:为了缩短停顿，4步：1初始标记gcroot：会stop the word
                                              2并发标记：可达的；和用户线程并发运行
                                              3重标记：标记并发标记过程用户程序改变的引用
                                              4并发清除
                             优点：并发，停顿时间短
                             缺点：1cpu资源敏感，开启的回收线程（cpu+3）/4占用cpu,在cpu少会变慢
                                  2并发清除时会产生浮动垃圾，要下一次回收，用户线程在运行设置触发老年代空间回收的百分比
                                      需预留空间否则会conccurent mode failure触发serialold回收
                                  3会产生碎片，无法为大对象分配连续空间时，通过参数设置解决
                        7G1收集器：并行与并发缩短时间
                                  分代收集：能独立管理整个堆，用不同的策略回收新创建的和已存活一段时间的对象
                                  空间整合：整体是标记压缩，局部region是复制算法
                                  可预测的停顿时间:在M秒内的停顿时间不超过N秒
                                  
                                  分成大小相等的region，避免在全堆进行回收，跟踪region的回收价值（回收空间收益与时间成本），维护一个列表在允许的时间内
                                  回收价值最大的region，region之间的对象引用，通过rememberset来避免全堆扫描，进行写操作会检查reference引用的对象
                                  是否处在不同的region，是就把引用信息记录到被引用的对象所处的region的rememberset中，进行回收在gcroot枚举范围
                                  加入rememberset，避免全堆扫描也可保证不遗漏引用信息
                                  步骤和cms差不多：1初始标记：停顿线程让用户线程在正确的region产生对象
                                                  2并发标记
                                                  3最终标记：记录并发标记发生变化的记录到remembersetlogs并合并到rememberset
                                                  4筛选回收会对region回收价值进行排序
                                                  
gc日志：full gc会stop the word，发生的区域名有收集器决定
  对象优先分配到Eden区，空间不够触发minor gc,回收过程s1存不了会放到老年代，回收后还不够在老年代分配
  大对象直接分配到老年代，长存活的将进入老年代，由对象年龄设置决定默认15
  动态对象年龄判断
  空间分配担保

jps:虚拟机进程信息
jstat：虚拟机进程统计信息：类装载，内存垃圾收集运行期编译状况
jinfo:java配置信息：各项参数
jmap:内存映像工具
jhat:堆转储快照分析工具
jstack：堆栈跟踪工具生成线程快照分析时间长或者死锁死循环等
jconsole:监控和管理内存和线程
visualVM:all-in-one
        显示进程的配置和环境信息
        监视cpu，gc，堆方法区和线程信息
        dump及分析堆转储快照
        方法级的运行性能分析，找出被调用最多，运行最长的方法
        
        
jvm与class字节码文件关联而不与语言关联
    class文件包含java虚拟机指令集和符号表、辅助信息（强制语法和结构化约束）
    字节码命令
    编译器把源代码编译成class文件，jvm读取运行

class类文件的结构：一组8位字节为基础单位的二进制流
  每个class文件的头4字节称为魔数紧接着的4字节是class文件版本号，版本号后紧接着常量池，常量池结束后是访问标志（access_flags)，
  类索引和父类索引和接口集合索引按序排在访问标志后，字段表集合，方法表集合ACC_SYNCHRONIZED,属性表集合，方法会编译成指令存在code属性里，
  max_stack栈最多深度，max_locals是局部变量表的空间32位的slot为单位可重用，实例方法的局部变量表会有一个执行当前实例的参数，
  
  jvm指令：操作码范围：一个字节长度0~255，操作数跟随在操作码后，大多指令包含了操作的数据类型信息，加载和存储指令，运算指令，类型转换指令
           对象创建与访问指令，操作数栈管理指令，控制转移指令，方法调用和返回指令，异常处理指令，同步指令（monitor支持），
           同步方法通过ACC_synchronize实现，指令集monitorenter和monitorexit支持
           
类加载机制：class加载到内存，校验、解析、初始化变成虚拟机使用的java类型，如运行时指定实现类
          生命周期：加载、连接（验证，准备、解析）、初始化、使用、卸载
          使用new、读取设置静态类属性，调用类的静态方法、反射调用、
          
          类加载过程：加载阶段：1全限定名获取类的二进制字节流
                              2字节流的静态结构转化成方法区运行时数据结构
                              3内存中生成代表类的java.lang.Class对象
                     验证阶段：确保class文件的信息符合要求，解析存储于方法区，符合描述一个java类型的格式
                              1文件格式验证：是否以魔数开头、主次版本号是否在虚拟机范围、常量池是否有不被支持的类型、指向常量的索引是否有指向不存在的
                                常量，constant_utf8_info型的常量是否有不符合utf8的编码数据、class文件是否有被删除和附加的部分
                              2元数据验证：信息符合java规范的要求
                                          1是否继承了final类型的类，不是抽象类是否实现父类或接口要求的方法，是否赋给父类final字段，重载方法是否合法
                              3字节码检验：保证执行不能跳转到方法体外，类型转换是有效的
                              4符号引用验证：引用字符串的全限定名能否找到类，方法和字段或抛出nosuchfield、nosuchmethod异常-XVerify:none跳过验证
                                            符号中引用的类、字段、方法的访问性（public）是否可被当前类访问
                     准备阶段：为类变量分配内存，赋初始零值，final的赋初始值、
                     
                     解析阶段：符号引用替换为直接引用，符号引用：符号所引用的目标，直接引用：指向目标的指针
                              1类或接口解析:在某个类中加载解析调用的类
                              2字段解析：查找某个类或父级是否存在字段简单名称，和访问权限
                              3接口解析,方法解析与字段解析类似
                     初始化阶段：类加载的最后一步，初始化代码，静态代码块，静态变量等，会锁定同步
         类加载器：不同的类加载器有命名空间区分
         双亲委派模型:类加载器接收到一个类加载请求会把请求交给父加载器父加载器无法加载在尝试自己加载
         线程上下文类加载器(默认是应用程序类加载器)破坏双亲委派，
